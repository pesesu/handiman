{
  "version": 3,
  "sources": ["../../react-sticky-box/dist/index.js"],
  "sourcesContent": ["// src/index.tsx\nimport { useEffect, useState } from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar getScrollParent = (node) => {\n  let parent = node;\n  while (parent = parent.parentElement) {\n    const overflowYVal = getComputedStyle(parent, null).getPropertyValue(\"overflow-y\");\n    if (parent === document.body)\n      return window;\n    if (overflowYVal === \"auto\" || overflowYVal === \"scroll\" || overflowYVal === \"overlay\") {\n      return parent;\n    }\n  }\n  return window;\n};\nvar isOffsetElement = (el) => el.firstChild ? el.firstChild.offsetParent === el : true;\nvar offsetTill = (node, target) => {\n  let current = node;\n  let offset = 0;\n  if (!isOffsetElement(target)) {\n    offset += node.offsetTop - target.offsetTop;\n    target = node.offsetParent;\n    offset += -node.offsetTop;\n  }\n  do {\n    offset += current.offsetTop;\n    current = current.offsetParent;\n  } while (current && current !== target);\n  return offset;\n};\nvar getParentNode = (node) => {\n  let currentParent = node.parentElement;\n  while (currentParent) {\n    const style = getComputedStyle(currentParent, null);\n    if (style.getPropertyValue(\"display\") !== \"contents\")\n      break;\n    currentParent = currentParent.parentElement;\n  }\n  return currentParent || window;\n};\nvar stickyProp = null;\nif (typeof CSS !== \"undefined\" && CSS.supports) {\n  if (CSS.supports(\"position\", \"sticky\"))\n    stickyProp = \"sticky\";\n  else if (CSS.supports(\"position\", \"-webkit-sticky\"))\n    stickyProp = \"-webkit-sticky\";\n}\nvar passiveArg = false;\ntry {\n  const opts = Object.defineProperty({}, \"passive\", {\n    // eslint-disable-next-line getter-return\n    get() {\n      passiveArg = { passive: true };\n    }\n  });\n  const emptyHandler = () => {\n  };\n  window.addEventListener(\"testPassive\", emptyHandler, opts);\n  window.removeEventListener(\"testPassive\", emptyHandler, opts);\n} catch (e) {\n}\nvar getDimensions = (opts) => {\n  const { el, onChange, unsubs, measure } = opts;\n  if (el === window) {\n    const getRect = () => ({ top: 0, left: 0, height: window.innerHeight, width: window.innerWidth });\n    const mResult = measure(getRect());\n    const handler = () => {\n      Object.assign(mResult, measure(getRect()));\n      onChange();\n    };\n    window.addEventListener(\"resize\", handler, passiveArg);\n    unsubs.push(() => window.removeEventListener(\"resize\", handler));\n    return mResult;\n  } else {\n    const mResult = measure(el.getBoundingClientRect());\n    const handler = () => {\n      Object.assign(mResult, measure(el.getBoundingClientRect()));\n      onChange();\n    };\n    const ro = new ResizeObserver(handler);\n    ro.observe(el);\n    unsubs.push(() => ro.disconnect());\n    return mResult;\n  }\n};\nvar getVerticalPadding = (node) => {\n  const computedParentStyle = getComputedStyle(node, null);\n  const parentPaddingTop = parseInt(computedParentStyle.getPropertyValue(\"padding-top\"), 10);\n  const parentPaddingBottom = parseInt(computedParentStyle.getPropertyValue(\"padding-bottom\"), 10);\n  return { top: parentPaddingTop, bottom: parentPaddingBottom };\n};\nvar setup = (node, unsubs, opts) => {\n  const { bottom, offsetBottom, offsetTop } = opts;\n  const scrollPane = getScrollParent(node);\n  let isScheduled = false;\n  const scheduleOnLayout = () => {\n    if (!isScheduled) {\n      requestAnimationFrame(() => {\n        const nextMode = onLayout();\n        if (nextMode !== mode) {\n          changeMode(nextMode);\n        } else if (nextMode === 1 /* stickyBottom */ && !bottom) {\n          const { height: viewPortHeight } = scrollPaneDims;\n          const { height: nodeHeight } = nodeDims;\n          node.style.top = `${viewPortHeight - nodeHeight - offsetBottom}px`;\n        } else if (nextMode === 2 /* relative */) {\n          const { height: viewPortHeight, offsetTop: scrollPaneOffset } = scrollPaneDims;\n          const { height: parentHeight, naturalTop } = parentDims;\n          const { height: nodeHeight } = nodeDims;\n          const relativeOffset2 = Math.max(\n            0,\n            scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom)\n          );\n          if (bottom) {\n            const nextBottom = Math.max(0, parentHeight - nodeHeight - relativeOffset2);\n            node.style.bottom = `${nextBottom}px`;\n          } else {\n            node.style.top = `${relativeOffset2}px`;\n          }\n        }\n        isScheduled = false;\n      });\n    }\n    isScheduled = true;\n  };\n  let latestScrollY = scrollPane === window ? window.scrollY : scrollPane.scrollTop;\n  const isBoxTooLow = (scrollY) => {\n    const { offsetTop: scrollPaneOffset, height: viewPortHeight } = scrollPaneDims;\n    const { naturalTop } = parentDims;\n    const { height: nodeHeight } = nodeDims;\n    if (scrollY + scrollPaneOffset + viewPortHeight >= naturalTop + nodeHeight + relativeOffset + offsetBottom) {\n      return true;\n    }\n    return false;\n  };\n  const onLayout = () => {\n    const { height: viewPortHeight } = scrollPaneDims;\n    const { height: nodeHeight } = nodeDims;\n    if (nodeHeight + offsetTop + offsetBottom <= viewPortHeight) {\n      return 3 /* small */;\n    } else {\n      if (isBoxTooLow(latestScrollY)) {\n        return 1 /* stickyBottom */;\n      } else {\n        return 2 /* relative */;\n      }\n    }\n  };\n  const scrollPaneIsOffsetEl = scrollPane !== window && isOffsetElement(scrollPane);\n  const scrollPaneDims = getDimensions({\n    el: scrollPane,\n    onChange: scheduleOnLayout,\n    unsubs,\n    measure: ({ height, top }) => ({\n      height,\n      offsetTop: scrollPaneIsOffsetEl ? top : 0\n    })\n  });\n  const parentNode = getParentNode(node);\n  const parentPaddings = parentNode === window ? { top: 0, bottom: 0 } : getVerticalPadding(parentNode);\n  const parentDims = getDimensions({\n    el: parentNode,\n    onChange: scheduleOnLayout,\n    unsubs,\n    measure: ({ height }) => ({\n      height: height - parentPaddings.top - parentPaddings.bottom,\n      naturalTop: parentNode === window ? 0 : offsetTill(parentNode, scrollPane) + parentPaddings.top + scrollPaneDims.offsetTop\n    })\n  });\n  const nodeDims = getDimensions({\n    el: node,\n    onChange: scheduleOnLayout,\n    unsubs,\n    measure: ({ height }) => ({ height })\n  });\n  let relativeOffset = 0;\n  let mode = onLayout();\n  const changeMode = (newMode) => {\n    const prevMode = mode;\n    mode = newMode;\n    if (prevMode === 2 /* relative */)\n      relativeOffset = -1;\n    if (newMode === 3 /* small */) {\n      node.style.position = stickyProp;\n      if (bottom) {\n        node.style.bottom = `${offsetBottom}px`;\n      } else {\n        node.style.top = `${offsetTop}px`;\n      }\n      return;\n    }\n    const { height: viewPortHeight, offsetTop: scrollPaneOffset } = scrollPaneDims;\n    const { height: parentHeight, naturalTop } = parentDims;\n    const { height: nodeHeight } = nodeDims;\n    if (newMode === 2 /* relative */) {\n      node.style.position = \"relative\";\n      relativeOffset = prevMode === 0 /* stickyTop */ ? Math.max(0, scrollPaneOffset + latestScrollY - naturalTop + offsetTop) : Math.max(\n        0,\n        scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom)\n      );\n      if (bottom) {\n        const nextBottom = Math.max(0, parentHeight - nodeHeight - relativeOffset);\n        node.style.bottom = `${nextBottom}px`;\n      } else {\n        node.style.top = `${relativeOffset}px`;\n      }\n    } else {\n      node.style.position = stickyProp;\n      if (newMode === 1 /* stickyBottom */) {\n        if (bottom) {\n          node.style.bottom = `${offsetBottom}px`;\n        } else {\n          node.style.top = `${viewPortHeight - nodeHeight - offsetBottom}px`;\n        }\n      } else {\n        if (bottom) {\n          node.style.bottom = `${viewPortHeight - nodeHeight - offsetBottom}px`;\n        } else {\n          node.style.top = `${offsetTop}px`;\n        }\n      }\n    }\n  };\n  changeMode(mode);\n  const onScroll = (scrollY) => {\n    if (scrollY === latestScrollY)\n      return;\n    const scrollDelta = scrollY - latestScrollY;\n    latestScrollY = scrollY;\n    if (mode === 3 /* small */)\n      return;\n    const { offsetTop: scrollPaneOffset, height: viewPortHeight } = scrollPaneDims;\n    const { naturalTop, height: parentHeight } = parentDims;\n    const { height: nodeHeight } = nodeDims;\n    if (scrollDelta > 0) {\n      if (mode === 0 /* stickyTop */) {\n        if (scrollY + scrollPaneOffset + offsetTop > naturalTop) {\n          const topOffset = Math.max(0, scrollPaneOffset + latestScrollY - naturalTop + offsetTop);\n          if (scrollY + scrollPaneOffset + viewPortHeight <= naturalTop + nodeHeight + topOffset + offsetBottom) {\n            changeMode(2 /* relative */);\n          } else {\n            changeMode(1 /* stickyBottom */);\n          }\n        }\n      } else if (mode === 2 /* relative */) {\n        if (isBoxTooLow(scrollY))\n          changeMode(1 /* stickyBottom */);\n      }\n    } else {\n      if (mode === 1 /* stickyBottom */) {\n        if (scrollPaneOffset + scrollY + viewPortHeight < naturalTop + parentHeight + offsetBottom) {\n          const bottomOffset = Math.max(\n            0,\n            scrollPaneOffset + latestScrollY + viewPortHeight - (naturalTop + nodeHeight + offsetBottom)\n          );\n          if (scrollPaneOffset + scrollY + offsetTop >= naturalTop + bottomOffset) {\n            changeMode(2 /* relative */);\n          } else {\n            changeMode(0 /* stickyTop */);\n          }\n        }\n      } else if (mode === 2 /* relative */) {\n        if (scrollPaneOffset + scrollY + offsetTop < naturalTop + relativeOffset) {\n          changeMode(0 /* stickyTop */);\n        }\n      }\n    }\n  };\n  const handleScroll = scrollPane === window ? () => onScroll(window.scrollY) : () => onScroll(scrollPane.scrollTop);\n  scrollPane.addEventListener(\"scroll\", handleScroll, passiveArg);\n  scrollPane.addEventListener(\"mousewheel\", handleScroll, passiveArg);\n  unsubs.push(\n    () => scrollPane.removeEventListener(\"scroll\", handleScroll),\n    () => scrollPane.removeEventListener(\"mousewheel\", handleScroll)\n  );\n};\nvar useStickyBox = ({\n  offsetTop = 0,\n  offsetBottom = 0,\n  bottom = false\n} = {}) => {\n  const [node, setNode] = useState(null);\n  useEffect(() => {\n    if (!node || !stickyProp)\n      return;\n    const unsubs = [];\n    setup(node, unsubs, { offsetBottom, offsetTop, bottom });\n    return () => {\n      unsubs.forEach((fn) => fn());\n    };\n  }, [node, offsetBottom, offsetTop, bottom]);\n  return setNode;\n};\nvar StickyBox = (props) => {\n  const { offsetTop, offsetBottom, bottom, children, className, style } = props;\n  const ref = useStickyBox({ offsetTop, offsetBottom, bottom });\n  return /* @__PURE__ */ jsx(\"div\", { className, style, ref, children });\n};\nvar src_default = StickyBox;\nexport {\n  src_default as default,\n  useStickyBox\n};\n"],
  "mappings": "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",
  "names": []
}
